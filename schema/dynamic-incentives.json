{
  "contract_name": "dynamic-incentives",
  "contract_version": "0.1.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "description": "Message type for `instantiate` entry_point",
    "type": "object",
    "required": [
      "osmo_base_reward",
      "owner"
    ],
    "properties": {
      "osmo_base_reward": {
        "$ref": "#/definitions/Coin"
      },
      "owner": {
        "type": "string"
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "description": "Message type for `execute` entry_point",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "add_to_gauge"
        ],
        "properties": {
          "add_to_gauge": {
            "type": "object",
            "required": [
              "gauge_id",
              "owner",
              "reward_amount"
            ],
            "properties": {
              "gauge_id": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "owner": {
                "type": "string"
              },
              "reward_amount": {
                "$ref": "#/definitions/Coin"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "create_gauge"
        ],
        "properties": {
          "create_gauge": {
            "type": "object",
            "required": [
              "coins",
              "is_perpetual",
              "num_epochs_paid_over",
              "owner"
            ],
            "properties": {
              "coins": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/Coin"
                }
              },
              "distribute_to": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/QueryCondition"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "is_perpetual": {
                "type": "boolean"
              },
              "num_epochs_paid_over": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "owner": {
                "type": "string"
              },
              "start_time": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Timestamp"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_osmo_base_reward"
        ],
        "properties": {
          "update_osmo_base_reward": {
            "type": "object",
            "required": [
              "new_base_reward"
            ],
            "properties": {
              "new_base_reward": {
                "$ref": "#/definitions/Coin"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_owner_addr"
        ],
        "properties": {
          "update_owner_addr": {
            "type": "object",
            "required": [
              "addr"
            ],
            "properties": {
              "addr": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "create_denom"
        ],
        "properties": {
          "create_denom": {
            "type": "object",
            "required": [
              "subdenom"
            ],
            "properties": {
              "initial_mint": {
                "type": [
                  "string",
                  "null"
                ]
              },
              "initial_pool": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/InitPoolCfg"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "subdenom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "lock_tokens"
        ],
        "properties": {
          "lock_tokens": {
            "type": "object",
            "required": [
              "coins",
              "owner"
            ],
            "properties": {
              "coins": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/Coin"
                }
              },
              "duration": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Duration"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "create_pool"
        ],
        "properties": {
          "create_pool": {
            "type": "object",
            "required": [
              "future_pool_governor",
              "pool_assets",
              "sender"
            ],
            "properties": {
              "future_pool_governor": {
                "type": "string"
              },
              "pool_assets": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/PoolAsset"
                }
              },
              "pool_params": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/PoolParams"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "sender": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Coin": {
        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.",
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "type": "string"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "Duration": {
        "type": "object",
        "required": [
          "nanos",
          "seconds"
        ],
        "properties": {
          "nanos": {
            "description": "Signed fractions of a second at nanosecond resolution of the span of time. Durations less than one second are represented with a 0 `seconds` field and a positive or negative `nanos` field. For durations of one second or more, a non-zero value for the `nanos` field must be of the same sign as the `seconds` field. Must be from -999,999,999 to +999,999,999 inclusive.",
            "type": "integer",
            "format": "int32"
          },
          "seconds": {
            "description": "Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years",
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "InitPoolCfg": {
        "type": "object",
        "required": [
          "exit_fee",
          "pairing_denom",
          "pool_assets",
          "swap_fee"
        ],
        "properties": {
          "exit_fee": {
            "type": "string"
          },
          "pairing_denom": {
            "type": "string"
          },
          "pool_assets": {
            "$ref": "#/definitions/PoolAssests"
          },
          "swap_fee": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "PoolAssests": {
        "type": "object",
        "required": [
          "new_token_amount",
          "new_token_weight",
          "pairing_token_amount",
          "pairing_token_weight"
        ],
        "properties": {
          "new_token_amount": {
            "type": "string"
          },
          "new_token_weight": {
            "type": "string"
          },
          "pairing_token_amount": {
            "type": "string"
          },
          "pairing_token_weight": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "PoolAsset": {
        "description": "Pool asset is an internal struct that combines the amount of the token in the pool, and its balancer weight. This is an awkward packaging of data, and should be revisited in a future state migration.",
        "type": "object",
        "required": [
          "weight"
        ],
        "properties": {
          "token": {
            "description": "Coins we are talking about, the denomination must be unique amongst all PoolAssets for this pool.",
            "anyOf": [
              {
                "$ref": "#/definitions/Coin"
              },
              {
                "type": "null"
              }
            ]
          },
          "weight": {
            "description": "Weight that is not normalized. This weight must be less than 2^50",
            "type": "string"
          }
        }
      },
      "PoolParams": {
        "description": "PoolParams defined the parameters that will be managed by the pool governance in the future. This params are not managed by the chain governance. Instead they will be managed by the token holders of the pool. The pool's token holders are specified in future_pool_governor.",
        "type": "object",
        "required": [
          "exit_fee",
          "swap_fee"
        ],
        "properties": {
          "exit_fee": {
            "type": "string"
          },
          "smooth_weight_change_params": {
            "anyOf": [
              {
                "$ref": "#/definitions/SmoothWeightChangeParams"
              },
              {
                "type": "null"
              }
            ]
          },
          "swap_fee": {
            "type": "string"
          }
        }
      },
      "QueryCondition": {
        "description": "QueryCondition is a struct used for querying locks upon different conditions. Duration field and timestamp fields could be optional, depending on the LockQueryType.",
        "type": "object",
        "required": [
          "denom",
          "lock_query_type"
        ],
        "properties": {
          "denom": {
            "description": "Denom represents the token denomination we are looking to lock up",
            "type": "string"
          },
          "duration": {
            "description": "Duration is used to query locks with longer duration than the specified duration. Duration field must not be nil when the lock query type is `ByLockDuration`.",
            "anyOf": [
              {
                "$ref": "#/definitions/Duration"
              },
              {
                "type": "null"
              }
            ]
          },
          "lock_query_type": {
            "description": "LockQueryType is a type of lock query, ByLockDuration | ByLockTime",
            "type": "integer",
            "format": "int32"
          },
          "timestamp": {
            "description": "Timestamp is used by locks started before the specified duration. Timestamp field must not be nil when the lock query type is `ByLockTime`. Querying locks with timestamp is currently not implemented.",
            "anyOf": [
              {
                "$ref": "#/definitions/Timestamp"
              },
              {
                "type": "null"
              }
            ]
          }
        }
      },
      "SmoothWeightChangeParams": {
        "description": "Parameters for changing the weights in a balancer pool smoothly from a start weight and end weight over a period of time. Currently, the only smooth change supported is linear changing between the two weights, but more types may be added in the future. When these parameters are set, the weight w(t) for pool time `t` is the following: t <= start_time: w(t) = initial_pool_weights start_time < t <= start_time + duration: w(t) = initial_pool_weights + (t - start_time) * (target_pool_weights - initial_pool_weights) / (duration) t > start_time + duration: w(t) = target_pool_weights",
        "type": "object",
        "required": [
          "initial_pool_weights",
          "target_pool_weights"
        ],
        "properties": {
          "duration": {
            "description": "Duration for the weights to change over",
            "anyOf": [
              {
                "$ref": "#/definitions/Duration"
              },
              {
                "type": "null"
              }
            ]
          },
          "initial_pool_weights": {
            "description": "The initial pool weights. These are copied from the pool's settings at the time of weight change instantiation. The amount PoolAsset.token.amount field is ignored if present, future type refactorings should just have a type with the denom & weight here.",
            "type": "array",
            "items": {
              "$ref": "#/definitions/PoolAsset"
            }
          },
          "start_time": {
            "description": "The start time for beginning the weight change. If a parameter change / pool instantiation leaves this blank, it should be generated by the state_machine as the current time.",
            "anyOf": [
              {
                "$ref": "#/definitions/Timestamp"
              },
              {
                "type": "null"
              }
            ]
          },
          "target_pool_weights": {
            "description": "The target pool weights. The pool weights will change linearly with respect to time between start_time, and start_time + duration. The amount PoolAsset.token.amount field is ignored if present, future type refactorings should just have a type with the denom & weight here.\n\nIntermediate variable for the 'slope' of pool weights. This is equal to (target_pool_weights - initial_pool_weights) / (duration) TODO: Work out precision, and decide if this is good to add repeated PoolAsset poolWeightSlope = 5 [ (gogoproto.moretags) = \"yaml:\\\"pool_weight_slope\\\"\", (gogoproto.nullable) = false ];",
            "type": "array",
            "items": {
              "$ref": "#/definitions/PoolAsset"
            }
          }
        }
      },
      "Timestamp": {
        "type": "object",
        "required": [
          "nanos",
          "seconds"
        ],
        "properties": {
          "nanos": {
            "description": "Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive.",
            "type": "integer",
            "format": "int32"
          },
          "seconds": {
            "description": "Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.",
            "type": "integer",
            "format": "int64"
          }
        }
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "description": "Message type for `query` entry_point",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "info"
        ],
        "properties": {
          "info": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_owner"
        ],
        "properties": {
          "get_owner": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_osmo_base_reward"
        ],
        "properties": {
          "get_osmo_base_reward": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "get_osmo_base_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "GetOsmoBaseRewardResponse",
      "type": "object",
      "required": [
        "osmo_base_reward"
      ],
      "properties": {
        "osmo_base_reward": {
          "$ref": "#/definitions/Coin"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_owner": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "GetOwnerResponse",
      "type": "object",
      "required": [
        "owner"
      ],
      "properties": {
        "owner": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "InfoResponse",
      "type": "object",
      "additionalProperties": false
    }
  }
}
